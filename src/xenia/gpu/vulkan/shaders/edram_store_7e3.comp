// NOTE: This file is compiled and embedded into the exe.
//       Use `xb genspirv` and check in any changes under bin/.

#version 450 core
#extension all : warn
#extension GL_ARB_compute_shader : require
#extension GL_ARB_separate_shader_objects : require
#extension GL_ARB_shader_image_load_store : require
#extension GL_ARB_shading_language_420pack : require

// 40x16 RT pixels to 40x16 EDRAM texels (80x16 threads per group is too much).
layout(local_size_x = 40, local_size_y = 16, local_size_z = 1) in;

layout(push_constant) uniform push_consts_type {
  uint edram_offset_tiles;
  uint edram_pitch_tiles;
  uvec2 rt_offset_px;
} push_constants;

layout(set = 0, binding = 0, r32ui) uniform writeonly uimage2D edram;
layout(set = 0, binding = 1, rg32ui) uniform readonly uimage2D rt;

// https://github.com/Microsoft/DirectXTex/blob/master/DirectXTex/DirectXTexConvert.cpp
uint Float16To7e3(uvec2 rg_ba_u32) {
  vec4 rgba_f32 =
      vec4(unpackHalf2x16(rg_ba_u32.r), unpackHalf2x16(rg_ba_u32.g));
  uvec3 rgb_u32 = floatBitsToUint(rgba_f32.rgb);

  // Only positive (high bit set means negative for both float and int), and
  // saturate to 31.875 (also dropping NaNs).
  rgb_u32 = uvec3(clamp(ivec3(rgb_u32), 0, 0x41FF73FF));

  // Convert values that are too small to denormalized.
  uvec3 denormalized =
      ((rgb_u32 & 0x7FFFFFu) | 0x800000u) >> (uvec3(125u) - (rgb_u32 >> 23u));
  rgb_u32 = mix(rgb_u32 + 0xC2000000u, denormalized,
                lessThan(rgb_u32, uvec3(0x3E800000u)));

  rgb_u32 = ((rgb_u32 + 0x7FFFu + ((rgb_u32 >> 16u) & 1u)) >> 16u) & 0x3FFu;
  return rgb_u32.b | (rgb_u32.g << 10) | (rgb_u32.r << 20) |
         (uint(clamp(rgba_f32.a, 0.0, 1.0) * 3.0) << 30);
}

void main() {
  uvec4 pixel = imageLoad(rt, ivec2(gl_GlobalInvocationID.xy +
                                    push_constants.rt_offset_px));
  pixel = uvec4(Float16To7e3(pixel.rg));
  uint tile_index = push_constants.edram_offset_tiles + gl_WorkGroupID.y *
                    push_constants.edram_pitch_tiles + (gl_WorkGroupID.x >> 1);
  uvec2 edram_coord = uvec2(tile_index & 15, tile_index >> 4) * uvec2(80, 16) +
                      gl_LocalInvocationID.xy;
  edram_coord.x += (gl_WorkGroupID.x & 1) * 40;
  imageStore(edram, ivec2(edram_coord), pixel);
}
